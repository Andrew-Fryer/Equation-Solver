<!DOCTYPE html>
<html>
<head>
  <title>Matrix solver</title>
</head>
<body>
  
  <form oninput="solution.value = Matrix.parseString(equations.value).toRREF().interpretMatrix()">
    <input type="text" id="equations"
      style="width: 100%;
      padding: 12px 20px;
      margin: 8px 0;
      display: inline-block;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box;">
    <output name="solution" for="equations"
      style="width: 100%;
      padding: 12px 20px;
      margin: 8px 0;
      display: inline-block;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box;"></output>
  </form>

  <script>
  
  class Matrix {
    constructor(m, n, headers) {
      this.data = new Array(m)
      for(let i=0; i<this.data.length; i++) {
        this.data[i] = new Array(n).fill(0)
      }
      this.m = m
      this.n = n
      this.headers = headers
    }
    // takes in 2 matrices
    multiply = (a,b) => {
      let result = new Matrix(a.m, b.n);
      for(let row=0; row<result.m; row++) {
        for(let col=0; col<result.n; col++) {
          let dotProduct = 0;
          for(let term=0; term<a.n; term++) {
            dotProduct += a.data[row][term] * b.data[term][col];
          }
          result.data[row][col] = dotProduct;
        }
      }
      return result;
    }
    swapRows = (a,b) => {
      let temp = this.data[a]
      data[a] = data[b]
      data[b] = temp
    }
    swapCols = (a,b) => {
      if(a == this.n-1 || b == this.n-1) {
        throw new Error("cannot swap constants row")
      }
      for(let i in this.data) {
        let myData = this.data[i]
        let temp = myData[a]
        myData[a] = myData[b]
        myData[b] = temp
      }
      let temp = this.headers[a]
      this.headers[a] = this.headers[b]
      this.headers[b] = temp
    }
    scaleBy = (row, alpha) => {
      if(alpha == 0) {
        throw new Error("Losing data")
      }
      for(let i in this.data[row]) {
        this.data[row][i] *= alpha
      }
    }
    addTo = (source, alpha, target) => {
      if(source == target && alpha == -1) {
        throw new Error("Losing data")
      }
      for(let i=0; i<this.n; i++) {
        this.data[target][i] += alpha * this.data[source][i]
      }
    }
    toRREF = () => {
      // for each row
      // s is the row and col of the current element that should be turned in a leading one with only zeros in the rest of its coloumn
      if(this.m>this.n) {
        throw new Error("too many rows??") // TODO: make too many rows safe -> deal with duplicate rows...
      }
      for(let s=0; s<this.m; s++) {
        // get the current col to be nonzero by swapping cols to the right
        for(let col=s; this.data[s][s] === 0; col++) {
          this.swapCols(s,col)  // the first swap is pointless... swapCols(0,0)
          if(col+1 >= this.n-1) {
            if(this.data[s][this.n-1] === 0) {
              // the current row is all zeros
              // TODO: goto swapCols "for(let col..." for the same row (repeat this row)
            } else {
              // all coefficients are zero, but the constant isn't
              throw new Error("there is no solution to this matrix")
            }
          }
        }
        // the current row should now be "in REF"
        // divide current col to make leading nonzero a one
        this.scaleBy(s,1/this.data[s][s])
        // subtract current row from all others to make all other elements in col of the current element zero
        for(let row in this.data) {
          if(row != s) {  // why is row a string?
            this.addTo(s,-this.data[row][s],row)
          }
        }
      }
      return this
    }
    deleteAllZeroCols = () => {
      for(let col=0; col<this.n; col ++) {
        let hasNonZero = false
        for(let row in this.data) {
          if(this.data[row][col] !== 0) {
            hasNonZero = true
            break
          }
        }
        if(!hasNonZero) {
          // remove coloumn
          for(let row in this.data) {
            this.data.splice(col, 1)
          }
        }
      }
    }
    deleteAllZeroRows = () => {
      for(let row in this.data) {
        let hasNonZero = false
        for(let col in this.data[row]) {
          if(this.data[row][col] != 0) {
            hasNonZero = true
            break
          }
        }
        if(!hasNonZero) {
          // remove row
          this.data.splice(row, 1)
        }
      }
    }

    static parseString = (str) => {
      str += "; " // ensure the last equation is parsed normally
      let strs = []
      // first divide into equations
      let index = str.search(";")
      while(index !== -1) {
        strs.push(str.slice(0,index))
        str = str.slice(index+1)  // +1 for the char ';'
        index = str.search(";")
      }
      
      // find variable names
      let varNamesArray = []
      for(let i in strs) {
        let myStr = strs[i]
        for(let j=0; j<myStr.length; j++) {
          let currentVarName = []
          let myASCII = myStr.charCodeAt(j)
          while((65<=myASCII && myASCII<=90) || (97<=myASCII && myASCII<=122)) {
            currentVarName.push(myStr[j])
            j++
            myASCII = myStr.charCodeAt(j)
          }
          varNamesArray.push(currentVarName)
        }
      }

      // remove duplicate variable names and make list of strings, not a list of lists of characters
      let varNames = []
      varNamesArray.forEach(varNameArray => {
        let varName = varNameArray.reduce((acc,s) => acc+s, "")
        if(!varNames.includes(varName) && varName !== "") {
          varNames.push(varName)
        }
      })
      
      // create matrix with dimensions
      let matrix = new Matrix(strs.length, varNames.length+1, varNames)

      // find and insert values
      let row = 0
      for(let i in strs) {
        let str = strs[i]
        str += " " // to ensure that the last term is parsed normally
        let buffer = [] // holds the latest characters
        let bufferType = ""
        let coefficient = 0
        let sign = 1 // holds 1 or -1
        for(let i in str) {
          let char = str[i]
          let charCode = char.charCodeAt(0)
          if((45 <= charCode && charCode <= 57) && charCode !== 47) {
            // the char is a number
            if(bufferType === "letter") {
              throw new Error("num right after letter")
            }
            buffer.push(char)
            bufferType = "num"
          } else if((97 <= charCode && charCode <= 122)
            || (65 <= charCode && charCode <= 90)) {
            // the char is letter
            if(bufferType === "num") {
              // flush the buffer into coefficient
              coefficient = sign * parseFloat(buffer.reduce((acc,s) => acc+s, ""))
              buffer = []
            } else if(bufferType === "") {
              coefficient = sign * 1
            }
            buffer.push(char)
            bufferType = "letter"
          } else {
            // the char is a symbol (whitespace)
            if(bufferType === "num") {
              // add the constant
              matrix.data[row][matrix.n-1] += -sign * parseFloat(buffer.reduce((acc,s) => acc+s, ""))
            } else if(bufferType === "letter") {
              // add the coefficent
              let col = matrix.headers.indexOf(buffer.reduce((acc,s) => acc+s, ""))
              matrix.data[row][col] += coefficient
              coefficient = 0
            }
            buffer = []
            bufferType = ""
            
            if(char === "=") {
              sign = -1
            }
          }
        }
        row += 1
      }
      return matrix
    }

// TODO: parameterize independent variables and print all variables in terms of the parameterized variables
    interpretMatrix = () => {
      let output = ""
      for(let rowIndex in this.data) {
        let row = this.data[rowIndex]
        let outputForCurrentRow = ""
        for(let colIndex in this.data[rowIndex]) {
          let val = this.data[rowIndex][colIndex]
          if(colIndex < this.n-1) { // if not a constant
            if(val !== 0) { // only print a variable if the coefficient is non-zero
              if(outputForCurrentRow!=="") {
                outputForCurrentRow += " + "
              }
              let varName = this.headers[colIndex]
              outputForCurrentRow += (val!==1 ? val.toString() : "") + varName + " "
            }
          } else {
            outputForCurrentRow += "= " + val.toString()
          }
        }
        output += outputForCurrentRow + "; "
      }
      return output
    }
  }

  compute = () => {
    let 
  }

// TODO: enforce plus and equals signs
//       check that syntax makes sense first...

  //Matrix.parseString(prompt("Enter semi-colon seperated linear equations (e.g. '3x + -5.67y + 54.2345243z= 3; 3x = 56 + y'): ")).toRREF().interpretMatrix()
  
  </script>
  
</body>
</html>