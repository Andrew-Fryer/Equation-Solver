<!DOCTYPE html>
<html>
<head>
  <title>Matrix solver</title>
</head>
<body>
  <script>
  
  class Matrix {
    constructor(m, n) {
      this.data = new Array(m)
      for(let i=0; i<this.data.length; i++) {
        this.data[i] = new Array(n).fill(0)
      }
      this.m = m
      this.n = n
    }
    swapRows = (a,b) => {
      let temp = this.data[a]
      data[a] = data[b]
      data[b] = temp
    }
    swapCols = (a,b) => {
      if(a == this.data.length-1 || b == this.data.length-1) {
        throw new Error("cannot swap constants row")
      }
      for(let i in this.data) {
        let myData = this.data[i]
        let temp = myData[a]
        myData[a] = myData[b]
        myData[b] = temp
      }
    }
    scaleBy = (row, alpha) => {
      if(alpha == 0) {
        throw new Error("Losing data")
      }
      for(let i in this.data[row]) {
        this.data[row][i] *= alpha
      }
    }
    addTo = (source, alpha, target) => {
      if((alpha == 0) || (source == target && alpha == -1)) {
        throw new Error("Losing data")
      }
      for(let i in this.data) {
        this.data[target][i] += alpha * this.data[source][i]
      }
    }
    toRREF = () => {
      // for each row
      // s is the row and col of the current element that should be turned in a leading one with only zeros in the rest of its coloumn
      if(this.m>this.n) {
        throw new Error("too many rows??") // TODO: make too many rows safe -> deal with duplicate rows...
      }
      for(let s=0; s<this.m; s++) {
        // get the current col to be nonzero by swapping cols to the right
        for(let col=s; this.data[s][s] === 0; col++) {
          this.swapCols(s,col)  // the first swap is pointless... swapCols(0,0)
          if(col+1 >= this.n-1) {
            if(this.data[s][this.n-1] === 0) {
              // the current row is all zeros
              // TODO: goto swapCols "for(let col..." for the same row (repeat this row)
            } else {
              // all coefficients are zero, but the constant isn't
              throw new Error("there is no solution to this matrix")
            }
          }
        }
        // the current row should now be "in REF"
        // divide current col to make leading nonzero a one
        this.scaleBy(s,1/this.data[s][s])
        // subtract current row from all others to make all other elements in col of the current element zero
        for(let row in this.data) {
          if(row != s) {  // why is row a string?
            this.addTo(s,-this.data[row][s],row)
          }
        }
      }
    }
    deleteAllZeroCols = () => {
      for(let col=0; col<this.n; col ++) {
        let hasNonZero = false
        for(let row in this.data) {
          if(this.data[row][col] !== 0) {
            hasNonZero = true
            break
          }
        }
        if(!hasNonZero) {
          // remove coloumn
          for(let row in this.data) {
            this.data.splice(col, 1)
          }
        }
      }
    }
    deleteAllZeroRows = () => {
      for(let row in this.data) {
        let hasNonZero = false
        for(let col in this.data[row]) {
          if(this.data[row][col] != 0) {
            hasNonZero = true
            break
          }
        }
        if(!hasNonZero) {
          // remove row
          this.data.splice(row, 1)
        }
      }
    }

    static parseString = (str) => {
      let strs = []
      // first divide into equations
      let index = str.search(";")
      while(index !== -1) {
        strs.push(str.slice(0,index))
        str = str.slice(index+1)  // +1 for the char ';'
        index = str.search(";")
      }
      
      // find variable names
      let varNamesArray = []
      // currently assuming that the string is a bunch of expressions (all equal to zero) seperated by semi-colons
      for(let i in strs) {
        let myStr = strs[i]
        for(let j=0; j<myStr.length; j++) {
          let currentVarName = []
          let myASCII = myStr.charCodeAt(j)
          while((65<=myASCII && myASCII<=90) || (97<=myASCII && myASCII<=122)) {
            currentVarName.push(myStr[j])
            j++
            myASCII = myStr.charCodeAt(j)
          }
          varNamesArray.push(currentVarName)
        }
      }

      // remove duplicate variable names and make list of strings, not a list of lists of characters
      let varNames = []
      varNamesArray.forEach(varNameArray => {
        let varName = varNameArray.reduce((acc,s) => acc+s, "")
        if(!varNames.includes(varName) && varName !== "") {
          varNames.push(varName)
        }
      })
      
      // create matrix with dimensions
      let matrix = new Matrix(strs.length, varNames.length+1)
      //matrix.headers = varNames
      console.log("hold debugger")

      let row = 0
      // find and insert values
      for(let i in strs) {
        let str = strs[i]
        str += "; " // to ensure that the last term is parsed normally
        let buffer = [] // holds the latest characters
        let bufferType = ""
        let coefficient = 0
        for(let i in str) {
          let char = str[i]
          let charCode = char.charCodeAt(0)
          if(48 <= charCode && charCode <= 57) {
            // the char is a number
            if(bufferType === "") {
              buffer.push(char)
              bufferType = "num"
            } else if(bufferType === "num") {
              buffer.push(char)
            } else if(bufferType === "letter") {
              throw new Error("num right after letter")
            }
          } else if((97 <= charCode && charCode <= 122)
            || (65 <= charCode && charCode <= 90)) {
            // the char is letter
            if(bufferType === "") {
              buffer.push(char)
              bufferType = "letter"
            } else if(bufferType === "letter") {
              buffer.push(char)
            } else if(bufferType === "num") {
              // flush the buffer into coefficient
              coefficient = parseFloat(buffer.reduce((acc,s) => acc+s, ""))
              buffer = []
              buffer.push(char)
              bufferType = "letter"
            }
          } else {
            // the char is a symbol (whitespace)
            if(bufferType === "") {
              // do nothing
            } else if(bufferType === "num") {
              // add the constant
              matrix.data[row][matrix.n-1] = parseFloat(buffer.reduce((acc,s) => acc+s, ""))
              buffer = []
              bufferType = ""
            } else if(bufferType === "letter") {
              // add the coefficent
              let col = varNames.indexOf(buffer.reduce((acc,s) => acc+s, ""))
              matrix.data[row][col] = coefficient
              coefficient = 0
              buffer = []
              bufferType = ""
            }
          }
        }
        row += 1
      }
      return matrix
    }
  }

// TODO: add "-" and "=" signs

  // note: ["m","y","V","a","r"].reduce((acc, s) => acc+s, "") -> "myVar"

  Matrix.parseString("3x 7y 3; 3x 4y 2;") // .toRREF().interpretMatrix()
  console.log("done debugging")
  
  </script>
  
</body>
</html>